# -*- coding: utf-8 -*-
"""phoenix-autocall-monte-carlo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15mqsmLXWxYFxMajMI9pVnr39cFvYq__w
"""

import numpy as np
import time

def phoenix_autocall_mc(S0, r, q, sigma, T, n_obs, n_sim):
    """
    Phoenix Autocall (Monte Carlo) – simplified version.

    Principle:
    - We simulate n_sim underlying paths (GBM) at observation dates
    - At each observation date:
        * if S >= autocall barrier → redemption + coupon (+ memory) and termination
        * else if S >= coupon barrier → coupon payment (+ memory), memory reset
        * else → coupon stored in memory
    - At maturity (if no autocall):
        * nominal redemption
        * unless S_T < capital barrier → capital loss proportional to final performance
    """

    # --- Time parameters ---
    dt = T / n_obs

    # --- Product parameters ---
    autocall_barrier = 1.00 * S0
    coupon_barrier   = 0.70 * S0
    capital_barrier  = 0.60 * S0

    coupon_rate = 0.02   # 2% per period
    nominal = 100

    # --- Path simulation (GBM) ---
    np.random.seed(42)  # reproducibility

    prices = np.zeros((n_sim, n_obs + 1))
    prices[:, 0] = S0   # all paths start at S0

    shocks = np.random.randn(n_sim, n_obs)

    drift = (r - q - 0.5 * sigma**2) * dt
    vol_step = sigma * np.sqrt(dt)

    for t in range(1, n_obs + 1):
        prices[:, t] = prices[:, t-1] * np.exp(drift + vol_step * shocks[:, t-1])

    # --- Payoff computation ---
    payoff = np.zeros(n_sim)

    alive = np.ones(n_sim, dtype=bool)   # product still alive
    coupon_memory = np.zeros(n_sim)      # accumulated coupons

    for t in range(1, n_obs + 1):
        St = prices[:, t]
        discount = np.exp(-r * t * dt)

        # 1) Autocall
        autocall = alive & (St >= autocall_barrier)
        payoff[autocall] += (nominal + nominal * coupon_rate + coupon_memory[autocall]) * discount
        alive[autocall] = False

        # 2) Coupon payment (if product still alive)
        coupon = alive & (St >= coupon_barrier)
        payoff[coupon] += (nominal * coupon_rate + coupon_memory[coupon]) * discount
        coupon_memory[coupon] = 0

        # 3) Coupon not paid → stored in memory
        missed = alive & (St < coupon_barrier)
        coupon_memory[missed] += nominal * coupon_rate

    # --- Maturity payoff ---
    ST = prices[:, n_obs]
    discount_T = np.exp(-r * T)

    still_alive = alive

    # Nominal redemption by default
    payoff[still_alive] += nominal * discount_T

    # Capital loss if the protection barrier is breached
    capital_loss = still_alive & (ST < capital_barrier)

    payoff[capital_loss] -= nominal * discount_T
    payoff[capital_loss] += (ST[capital_loss] / S0 * nominal) * discount_T

    # --- Monte Carlo result ---
    price = np.mean(payoff)
    mc_error = np.std(payoff, ddof=1) / np.sqrt(n_sim)

    return price, mc_error


# --- Example run ---
S0 = 100
r = 0.05
q = 0.00
sigma = 0.20
T = 5.0
n_obs = 5
n_sim = 50000

start = time.time()
price, error = phoenix_autocall_mc(S0, r, q, sigma, T, n_obs, n_sim)
end = time.time()

print("PHOENIX AUTOCALL – Monte Carlo (simplified)")
print(f"Price: {price:.4f}")
print(f"MC error: {error:.4f}")
print(f"Computation time: {end - start:.2f}s")

