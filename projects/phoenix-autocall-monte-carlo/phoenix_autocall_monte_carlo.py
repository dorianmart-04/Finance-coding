# -*- coding: utf-8 -*-
"""phoenix-autocall-monte-carlo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15mqsmLXWxYFxMajMI9pVnr39cFvYq__w
"""

import numpy as np
import time

def phoenix_autocall_mc(S0, r, q, sigma, T, n_obs, n_sim):
    """
    Phoenix Autocall (Monte Carlo) - version simple.

    Principe :
    - On simule n_sim trajectoires du sous-jacent (GBM) aux dates d'observation
    - À chaque date :
        * si S >= barrière autocall → remboursement + coupon (+ mémoire) et arrêt
        * sinon si S >= barrière coupon → paiement du coupon (+ mémoire), mémoire remise à zéro
        * sinon → coupon stocké en mémoire
    - À maturité (si pas d'autocall) :
        * remboursement du nominal
        * sauf si S_T < barrière capital → perte proportionnelle à la performance finale
    """

    # --- Paramètres temporels ---
    dt = T / n_obs

    # --- Paramètres du produit ---
    autocall_barrier = 1.00 * S0
    coupon_barrier   = 0.70 * S0
    capital_barrier  = 0.60 * S0

    coupon_rate = 0.02   # 2 % par période
    nominal = 100

    # --- Simulation des trajectoires (GBM) ---
    np.random.seed(42)  # reproductibilité des résultats

    prices = np.zeros((n_sim, n_obs + 1))
    prices[:, 0] = S0   # toutes les trajectoires commencent à S0

    shocks = np.random.randn(n_sim, n_obs)

    drift = (r - q - 0.5 * sigma**2) * dt
    vol_step = sigma * np.sqrt(dt)

    for t in range(1, n_obs + 1):
        prices[:, t] = prices[:, t-1] * np.exp(drift + vol_step * shocks[:, t-1])

    # --- Calcul des payoffs ---
    payoff = np.zeros(n_sim)

    alive = np.ones(n_sim, dtype=bool)   # produit encore en vie
    coupon_memory = np.zeros(n_sim)      # coupons mémorisés

    for t in range(1, n_obs + 1):
        St = prices[:, t]
        discount = np.exp(-r * t * dt)

        # 1) Autocall
        autocall = alive & (St >= autocall_barrier)
        payoff[autocall] += (nominal + nominal * coupon_rate + coupon_memory[autocall]) * discount
        alive[autocall] = False

        # 2) Coupon (si produit toujours en vie)
        coupon = alive & (St >= coupon_barrier)
        payoff[coupon] += (nominal * coupon_rate + coupon_memory[coupon]) * discount
        coupon_memory[coupon] = 0

        # 3) Coupon non payé → mise en mémoire
        missed = alive & (St < coupon_barrier)
        coupon_memory[missed] += nominal * coupon_rate

    # --- Traitement à maturité ---
    ST = prices[:, n_obs]
    discount_T = np.exp(-r * T)

    still_alive = alive

    # Remboursement du nominal par défaut
    payoff[still_alive] += nominal * discount_T

    # Perte en capital si la barrière de protection est franchie
    capital_loss = still_alive & (ST < capital_barrier)

    payoff[capital_loss] -= nominal * discount_T
    payoff[capital_loss] += (ST[capital_loss] / S0 * nominal) * discount_T

    # --- Résultat Monte Carlo ---
    price = np.mean(payoff)
    mc_error = np.std(payoff, ddof=1) / np.sqrt(n_sim)

    return price, mc_error


# --- Exemple d'exécution ---
S0 = 100
r = 0.05
q = 0.00
sigma = 0.20
T = 5.0
n_obs = 5
n_sim = 50000

start = time.time()
price, error = phoenix_autocall_mc(S0, r, q, sigma, T, n_obs, n_sim)
end = time.time()

print("PHOENIX AUTOCALL – Monte Carlo (simple)")
print(f"Prix : {price:.4f}")
print(f"Erreur MC : {error:.4f}")
print(f"Temps de calcul : {end - start:.2f}s")

