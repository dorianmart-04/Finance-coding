# -*- coding: utf-8 -*-
"""rates-credit-shock-monitor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wyc7rJg_abaCP8CeTiySEsrkHmfLYDwR
"""

# PART 0 — Imports and general parameters

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt

# Market proxies:
# ^TNX : US 10-year Treasury yield (rates)
# LQD  : Investment Grade credit
# HYG  : High Yield credit
tickers = ["^TNX", "LQD", "HYG"]

start_date = "2015-01-01"
end_date = None                 # None = up to today

rolling_window = 60             # 60 trading days (~3 months)
quantile_low = 0.05             # lower threshold to define a shock
quantile_high = 0.95            # upper threshold to define a shock

# PART 1 — Data download and cleaning

# Download data from Yahoo Finance
data = yf.download(
    tickers,
    start=start_date,
    end=end_date,
    auto_adjust=True,
    progress=False
)

# Keep only closing prices
# (for multiple tickers, this results in a MultiIndex)
prices = data["Close"].copy()

# Data cleaning:
# - drop rows that are entirely empty
# - forward-fill missing values
prices = prices.dropna(how="all")
prices = prices.ffill()

print("Latest price observations:")
print(prices.tail())

# PART 2 — Return computation

# Daily returns (percentage)
returns = prices.pct_change().dropna()

print("\nDescriptive statistics of returns:")
print(returns.describe().T)

# PART 3 — Price level charts

# 3.1 Raw price levels
prices.plot()
plt.title("Rates & Credit Proxies — Price Levels")
plt.xlabel("Date")
plt.ylabel("Level / Price")
plt.grid(True)
plt.tight_layout()
plt.show()

# 3.2 Normalized price levels (base 100 at inception)
# Allows comparison of dynamics despite different scales
normalized_prices = prices / prices.iloc[0] * 100

normalized_prices.plot()
plt.title("Rates & Credit Proxies — Normalized Levels (base 100)")
plt.xlabel("Date")
plt.ylabel("Normalized Index")
plt.grid(True)
plt.tight_layout()
plt.show()

# PART 4 — Rolling volatility and correlation

# Annualized volatility computed over a rolling window
rolling_vol = returns.rolling(rolling_window).std() * np.sqrt(252)

rolling_vol.plot()
plt.title(f"Rolling volatility ({rolling_window} days, annualized)")
plt.xlabel("Date")
plt.ylabel("Annualized volatility")
plt.grid(True)
plt.tight_layout()
plt.show()

# Correlation matrix of returns
corr_matrix = returns.corr()

print("\nCorrelation matrix:")
print(corr_matrix)

# Simple correlation heatmap
plt.imshow(corr_matrix.values)
plt.xticks(range(len(corr_matrix.columns)), corr_matrix.columns, rotation=45)
plt.yticks(range(len(corr_matrix.index)), corr_matrix.index)
plt.title("Return correlation heatmap")
plt.tight_layout()
plt.show()

# PART 5 — Market shock detection

# Empirical thresholds based on quantiles
quantiles = returns.quantile([quantile_low, quantile_high])

print("\nQuantiles used for shock detection:")
print(quantiles)

# A shock is defined as an extreme return
shock_mask = (
    (returns < quantiles.loc[quantile_low]) |
    (returns > quantiles.loc[quantile_high])
)

# Systemic shock day = at least one asset in shock on that day
system_shock_days = shock_mask.any(axis=1)

print("\nTotal number of systemic shock days:", int(system_shock_days.sum()))

# PART 6 — Summary table

summary_table = pd.DataFrame({
    "average_daily_return": returns.mean(),
    "annualized_volatility": returns.std() * np.sqrt(252),
    "number_of_shock_days": shock_mask.sum(),
    "worst_day": returns.min(),
    "best_day": returns.max(),
})

print("\nSummary table:")
print(summary_table)

# PART 7 — Shock-focused charts

# 7.1 Daily returns with shock highlighting
for asset in returns.columns:
    plt.figure()
    plt.plot(returns.index, returns[asset], linewidth=1)
    plt.scatter(
        returns.index[shock_mask[asset]],
        returns.loc[shock_mask[asset], asset],
        s=10
    )
    plt.title(f"{asset} — Daily returns with shocks")
    plt.xlabel("Date")
    plt.ylabel("Daily return")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# 7.2 LQD vs HYG on normal days
plt.figure()
plt.scatter(
    returns.loc[~system_shock_days, "LQD"],
    returns.loc[~system_shock_days, "HYG"],
    s=8
)
plt.title("LQD vs HYG — Normal days")
plt.xlabel("LQD return")
plt.ylabel("HYG return")
plt.grid(True)
plt.tight_layout()
plt.show()

# 7.3 LQD vs HYG on systemic shock days
plt.figure()
plt.scatter(
    returns.loc[system_shock_days, "LQD"],
    returns.loc[system_shock_days, "HYG"],
    s=12
)
plt.title("LQD vs HYG — Systemic shock days")
plt.xlabel("LQD return")
plt.ylabel("HYG return")
plt.grid(True)
plt.tight_layout()
plt.show()

# 7.4 Focus on rate shocks (^TNX)
tnx_low = returns["^TNX"].quantile(quantile_low)
tnx_high = returns["^TNX"].quantile(quantile_high)

tnx_shock_days = (
    (returns["^TNX"] <= tnx_low) |
    (returns["^TNX"] >= tnx_high)
)

plt.figure()
plt.scatter(
    returns.loc[tnx_shock_days, "LQD"],
    returns.loc[tnx_shock_days, "HYG"],
    s=12
)
plt.title("LQD vs HYG — Rate shock days (^TNX)")
plt.xlabel("LQD return")
plt.ylabel("HYG return")
plt.grid(True)
plt.tight_layout()
plt.show()

# PART 8 — Mini “daily report” snapshot

# Extract indicators for the latest available date
last_date = returns.index[-1]

daily_snapshot = pd.DataFrame({
    "last_return": returns.loc[last_date],
    "rolling_annualized_volatility": rolling_vol.loc[last_date],
    "shock_today": shock_mask.loc[last_date],
})

print("\nSnapshot for the latest day:", last_date.date())
print(daily_snapshot)